= BSB
:toc:
:toc-title: Contents
:nofooter:
:stem: latexmath

== Dynamic Programming

Dynamic programming makes string matching and searching more simple

Solve a big problem by dividing it into smaller subproblems

* combine solutions to subproblems -> problem solved

Several algorithms exist for these applications

=== Needleman-Wunsch algorithm

Used for *global alignment*

Maps 2 strings onto a matrix stem:[S]

* one along x axis
* other along y axis
* stores the optimal subsequence alignment

stem:[S_{i, j}] contains the optimal score for `A[0: i-1]` and `B[0: j-1]`

Computes scores according to this formula:

[stem]
++++
S_{i, j} = 
    \max (
        S_{i-1, j-1} + \text{sm}(a_i, b_j),
        S_{i-1, j} + g,
        S_{i-1, j-1} + g
    )
++++

where:

* stem:[\text{sm}] is the substitution matrix
** BLOSUM50/62
** PAM250
* stem:[g] is the gap penalty

The exact scores change depending on the substitution matrix used

The final score is in the bottom right corner

* we need the route as well
* need to trace back through the matrix and find what brought us to the final score

Use a trace matrix of identical size using 3 symbols

* up
* diagonal
* right/left

=== Smith-Waterman algorithm

Used for *local alignment*

* partial alignments are ok

Can obtain negative scores

* if negative restart alignment with score = 0

Matrix is similar to Needleman-Wunsch

* squares nearest to strings are filled with 0

The final score is equal to the highest number

* this can be anywhere in the matrix because the alignment is local
* there can be multiple final scores
** one may be a substring of either of the input strings
** we don't necessarily want that

Traceback matrix still required

=== Heuristic Alignment algorithm

The previous algorithms are nice and fast but they can become quite complex because complexity grows linearly with the size of the input

* `O(n*m)`

*Heuristic algorihtms* return partial alignment much faster than exhaustive algorithms

* up to 100x speedup
* do not guarantee the best possible solution

== BLAST

String processing tool

*Basic Local Alignment Search Tool*

Uses short perfectly matching substrings to increase the size of the local alignment

* this means that any alignment will have a short series of perfectly matching substrings
* we can expand the local alignment using those substring as a basis
* this should give us longer alignments

Uses the following parameters:

* stem:[w]: length of target words
* stem:[T]: local alignment score threshold
** store all words (substrings) with score stem:[ \gt T]

Returns a lot of possible matches

* need to pick which match we like best
* what criteria do we use?

Also available online at the NCBI website

Not all results are significant:

* *e* value represents the expected number of hits with the observed score or higher than would have been seen by chance
** like the p value
** lower is better

More specific and optimized versions exist

=== BLAST steps (generic)

. Remove low complexity regions
* usually sequence repeats
* like `AAAAAAAA`
* or nonsense `ATCGGAGAGTAGGCATGAGT`

. Obtain all words with length stem:[w] that occur in the sequence
* overlapping words
* break the larger sequence into appropriately sized chunks (stem:[w])
* stem:[w=3] for proteins
* stem:[w=11] for nucleotides

. For each word compile a list of all possible words with length stem:[w] that can be defined in the allowed alphabet
* `ATGC` for DNA
* `AUGC` for RNA
* these are called *neighbors*
** they are words that could plausibly be used to replace the current word and still get a nice score
* keep those whose local alignment is stem:[\gt T]
** stem:[T] is obtained by the chosen substitution matrix

. Find those words in the database
* the database is indexed by all possible words of length stem:[w]
** it's really a hash table/dictionary
* retrieved positions are called *seed hits*
** or *HSP seeds*
* the neighborhood words are used as a key
** used to retrieve occurrences of that word in the target sequences

. Extend hits in both directions
* no gaps
* pairwise alignment with substitution matrix

. Get the highest score from the previous step
* each alignment is given a raw score
* which is converted to a *bit score* and an *E value*
** the bit score is a normalized raw score
** the E value is the expected number of the number of random hits with equal or higher score
*** lower is better

=== BLASTN

Specifically for nucleotides

Optimized for highly similar sequences

Parameters:

* stem:[w=11]
* match score stem:[=2]
* mismatch penalty stem:[-3]
* gap opening stem:[=-5]
* gap extension stem:[-2]

=== BLASTP

Optimized for proteins

* prefers highly different sequences

Default parameters (can be modified)

* stem:[w=6]
* substitution matrix is `BLOSUM62`
* gap opening stem:[=-11]
* gap extension stem:[=-1]

=== BLASTX

Given a DNA query it searches over proteins

Translates the DNA seq with all 6 RF

Finds potential protein products encoded by the query

=== TBLASTN

Inverse of BLASTX

* given a protein it finds DNA that likely encodes it
** translate DNA with all possible starting points
** perform match with against translated DNASubsection 2

Used to find gene codings for input proteins

=== TBLASTX

All at the same time

Given a DNA query:

* search over another DNA sequence
* translate query into protein
* match translation against translation of other DNA sequence

Again using all 6 RF

* results in 36 comparisons
* finds nucleotides with similar coding potential to the query

== FASTA

Can also do alignments using diagonals

* finds good diagonals
* extend local matches using them

.Steps

. Identify short matches between the 2 sequences
* matches of length `ktup`
** length of matches
** large `ktup` values will be faster but less accurate
*** will increase false positives

. Identify diagonals with high short match density
* find local areas where there are lots of short matches

. Extend these along their diagonal
* expands the matches

. Join ungapped regions using gaps

. Realign the area
* use Smith-Waterman for local alignment
