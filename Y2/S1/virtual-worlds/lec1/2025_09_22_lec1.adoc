= Virtual Worlds - Overview
:toc:
:toc-title: Contents
:nofooter:
:stem: latexmath

== Evolution to virtual worlds

Virtual worlds started as simple parametric calculations

* generate a cube of size stem:[x \cdot y \cdot z]
* put a guy here
* put another guy there

Then they became more advanced simulations

* behaviors
* interactions

More advanced techniques

* procedural generation
** Perlin noise
** rule based generation
* 3D scanning
** LIDAR
** Photogrammetry

Digital twins

* virtual replicas of real things
** objects
** places
** people
** parts of people
* real time data
** avatars
** simulations
** can be used for data generation

== What is a Virtual World?

A computer simulated environment generated by several components

* mathematical representations
* geometric privileges
* behavioral algorithms

They typically require real time responsiveness to be useful

Different virtual worlds can exist:

* physical spaces
** historical sites
** hospitals
** normally inaccessible locations
*** space stations
*** deep sea wells

* abstract spaces
** places that can't easily exist in the real world
** mathematical structures
*** like standing in the Mandelbrot set

* imaginary spaces
** fantasy worlds
** futuristic environments

=== Healthcare applications

There are many potential applications

.Medical training
* simulating a patient with a particular (set of) condition(s)
* simulating a surgical intervention
* visualizing internal organs

.Therapeutic applications
* mental health treatments
** virtual meetings with psychologists
*** less immersive than real life meetings but more immersive than videocalls
* physical rehabilitation
** real time feedback if combined with other sensors/actuators

== Virtual World Types

There are 8 main types:

. Geometric
. Procedural
. Static
. Dynamic
. Real-time
. Pre-computed
. Discrete
. Continuous

Typically they can be combined (some options are mutually exclusive)

* Procedural dynamic worlds
** the world is generated as it's explored
* Real-time static geometric worlds
** exploring a defined unchanging space
** e.g. historical sites

=== Geometric vs procedural

Geometric worlds are explicitly defined by artists

* wall goes here
* floor looks like this
* room is this size
* chair goes in this corner
* typically high fidelity
* limited scope

While procedural worlds are generated by algorithms

* Perlin noise (terrain generation)
* Rule based
** wall can be here if there isn't another wall intersecting this area
* lower fidelity(*)
* potentially unlimited scope

=== Static vs Dynamic

Static worlds don't change with use

* predictable performance
** everything is always in the same place with the same parameters
** no real need to recompute stuff on the fly
** lighting and shadows can be baked in
* simpler systems
** navigation/pathfinding is easier
*** obstacles are always in the same place
*** do once keep forever

Dynamic worlds do change with use

* unpredictable performance
* state management is more complex
** changes have to be synced across all affected parts of the world
* real time physics and lighting
** very expensive

=== Real-time vs pre-computed

Pre-computed worlds are basically static renders

* render with very high fidelity
* high quality lighting
** path tracing et. al
* non interactive
* good for film/animation
* high quality visualization of scientific imagery
** organs
** molecules
** engineering structures

Real-time worlds are rendered as required

* must be rendered in real time (ish)
** for games 60 fps is enough
* less complex lighting and physics required
** calculations are expensive
** constant real time calculations are extremely taxing
* use LOD to make rendering cheaper
** render objects outside some predefined camera range at a lower quality
* use culling/occlusion to avoid rendering objects outside the camera's view
** no point rendering what's behind the camera
** no point rendering objects/parts of objects that are behind other objects

=== Discrete vs continuous

.Discrete worlds
Discrete worlds use grids to separate objects

* tiles
* voxels
** e.g. this space is 4x4x12 tiles

This makes a lot of things simpler:

* positioning
** avatar is in cell (90, 151)
* collision detection
** if cell occupied -> collision
* pathfinding
** classic algorithms like A* and Dijkstra work basically for free

.Continuous worlds
Continuous worlds use mathematically continuous surfaces

* manifolds
* parametric surfaces
* continuous mappings

This makes representations smoother than discrete worlds

* also allows for more realistic physics

It also makes some things more complicated

* collision detection now requires geometric intersection algorithms
* floating point precision becomes a problem
** what if the exact position of the avatar cannot be accurately represented by 32 bit floats?
*** have to use higher precision
*** more memory usage
*** potentially problematic

== Virtual World Architectures

4 main types:

. Client-server
* clients connect to server
** centralized or decentralized
* server handles communication with clients
* persistent database
. Peer to peer
* decentralized
* can leverage blockchain techniques
** immutability
** persistent logging
* peers responsible for different parts of processing
. Cloud based
* use SaaS platforms to host world
* more scalable
** can simply rent more VMs
. Edge computing
* done on smartphones and such
* big focus on efficiency
** local caching
** delta updates
** adaptive streaming
*** if on 0.5 mbps coax stream textures at 480p
*** if on 2.5gbps fiber stream textures at 4k